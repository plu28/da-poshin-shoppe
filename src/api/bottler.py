from fastapi import APIRouter, Depends
from enum import Enum
from pydantic import BaseModel
from src.api import auth
import sqlalchemy
from src import database as db
from src import global_inventory as gi
from src import catalog_table as ct
from src import log
router = APIRouter(
    prefix="/bottler",
    tags=["bottler"],
    dependencies=[Depends(auth.get_api_key)],
)

class PotionInventory(BaseModel):
    potion_type: list[int]
    quantity: int

@router.post("/deliver/{order_id}")
def post_deliver_bottles(potions_delivered: list[PotionInventory], order_id: int):
    """ """
    log.post_log(f"/deliver/{order_id}")

    global_inventory = gi.GlobalInventory().retrieve()

    # add potions to catalog table. if the potion doesn't exist, insert a new row
    for potion in potions_delivered:
        sku = type_to_sku(potion.potion_type)
        catalog_row = ct.CatalogInventory().retrieve(sku)
        if (catalog_row == None):
            # Add a new sku
            # TODO: Make it so the name is generated by an LLM to make it interesting
            # TODO: Generate a price for each potion added. Default price is 40
            insert_query = sqlalchemy.text("INSERT INTO catalog (sku, name, quantity, price, potion_type) VALUES (sku = :sku, name = :name, quantity = :quantity, price = :price, potion_type = :potion_type)")
            with db.engine.begin as connection:
                connection.execute(insert_query,
                    {
                        'sku': sku,
                        'name': sku,
                        'quantity': potion.quantity,
                        'price': 40,
                        'potion_type': potion.potion_type
                    }
                )
        else:
            # Update existing sku
            update_query = sqlalchemy.text("UPDATE global_inventory SET quantity = :quantity WHERE sku = :sku")
            with db.engine.begin as connection:
                connection.execute(update_query,
                    {
                        'quantity': catalog_row.quantity + potion.quantity,
                        'sku': sku
                    }
                )

    return "OK"

@router.post("/plan")
def get_bottle_plan():
    """
    Go from barrel to bottle.
    """
    # LOGGING
    with db.engine.begin() as connection:
        log = connection.execute(sqlalchemy.text(f"INSERT INTO logs (endpoint) VALUES ('/bottler/plan')"))

    # Each bottle has a quantity of what proportion of red, blue, and
    # green potion to add.
    # Expressed in integers from 1 to 100 that must sum up to 100.

    # Initial logic: bottle all barrels into green potions.
    # with db.engine.begin() as connection:
    #     result = connection.execute(sqlalchemy.text("SELECT num_green_ml FROM global_inventory"))

    # green_ml = result.fetchone().num_green_ml

    # # This is how many bottles im creating
    # bottle_quantity = green_ml // 100

    # V2 bottle plan: just always have 3 of each potion in stock

    # if bottle_quantity >= 1:
        # return [
        #         {
        #             "potion_type": [0, 100, 0, 0],
        #             "quantity": bottle_quantity,
        #         }
        #     ]
    # else:
    return []

def type_to_sku(potion_type):
    sku = []
    if potion_type[0] > 0:
        sku.append(f"{potion_type[0]}red")
    if potion_type[1] > 0:
        sku.append(f"{potion_type[1]}green")
    if potion_type[2] > 0:
        sku.append(f"{potion_type[2]}blue")
    if potion_type[3] > 0:
        sku.append(f"{potion_type[3]}dark")
    return "".join(sku)

if __name__ == "__main__":
    print(get_bottle_plan())
