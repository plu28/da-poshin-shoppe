from fastapi import APIRouter, Depends
from enum import Enum
from pydantic import BaseModel
from src.api import auth
import sqlalchemy
import json
import re
from src import database as db
from src import global_inventory as gi
from src import catalog_table as ct
from src import log
from src import prices
from src import strategy as strat

router = APIRouter(
    prefix="/bottler",
    tags=["bottler"],
    dependencies=[Depends(auth.get_api_key)],
)

class PotionInventory(BaseModel):
    potion_type: list[int]
    quantity: int

@router.post("/deliver/{order_id}")
def post_deliver_bottles(potions_delivered: list[PotionInventory], order_id: int):
    """ """
    log.post_log(f"/deliver/{order_id}")

    # add potions to catalog table. if the potion doesn't exist, insert a new row
    for potion in potions_delivered:
        sku = type_to_sku(potion.potion_type)
        catalog_row = ct.CatalogInventory().retrieve(sku)

        red_ml = potion.potion_type[0]
        green_ml = potion.potion_type[1]
        blue_ml = potion.potion_type[2]
        dark_ml = potion.potion_type[3]

        price = red_ml * prices.RED_PRICE_PER_ML + green_ml * prices.GREEN_PRICE_PER_ML + blue_ml * prices.BLUE_PRICE_PER_ML + dark_ml * prices.DARK_PRICE_PER_ML

        if (catalog_row == None):
            # TODO: Make it so the name is generated by an LLM to make it interesting
            insert_query = sqlalchemy.text("INSERT INTO catalog (sku, name, quantity, price, potion_type) VALUES (:sku, :name, :quantity, :price, :potion_type)")
            with db.engine.begin() as connection:
                connection.execute(insert_query,
                    {
                        'sku': sku,
                        'name': sku,
                        'quantity': potion.quantity,
                        'price': price,
                        'potion_type': potion.potion_type
                    }
                )
        else:
            # Update existing sku
            update_query = sqlalchemy.text("UPDATE catalog SET quantity = :quantity WHERE sku = :sku")
            with db.engine.begin() as connection:
                connection.execute(update_query,
                    {
                        'quantity': catalog_row.quantity + potion.quantity,
                        'sku': sku
                    }
                )

        # Decrement global inventory by how much we just bottled
        red_loss = green_loss = blue_loss = dark_loss = 0
        red_loss = red_ml * potion.quantity
        green_loss = green_ml * potion.quantity
        blue_loss = blue_ml * potion.quantity
        dark_loss = dark_ml * potion.quantity

        global_inventory = gi.GlobalInventory().retrieve()
        update_query = sqlalchemy.text("UPDATE global_inventory SET red_ml = :red_ml, green_ml = :green_ml, blue_ml = :blue_ml, dark_ml = :dark_ml")
        print(f"{global_inventory.red_ml} - {red_loss}")
        with db.engine.begin() as connection:
            connection.execute(update_query,
                {
                    'red_ml': global_inventory.red_ml - red_loss,
                    'green_ml': global_inventory.green_ml - green_loss,
                    'blue_ml': global_inventory.blue_ml - blue_loss,
                    'dark_ml': global_inventory.dark_ml - dark_loss
                }
            )

    return "OK"

@router.post("/plan")
def get_bottle_plan():
    """
    Go from barrel to bottle.
    """
    log.post_log('/bottler/plan')

    bottle_plan = []
    mystrat = strat.Strategy().retrieve_as_dict()
    for sku, quantity in mystrat.items():
        red_ml = green_ml = blue_ml = dark_ml = 0
        order = {}
        # Since sku corresponds to potion makeup, I can use regex
        for ml_quantity, color in re.findall("(\d+)([a-z]+)", sku):
            ml_quantity = int(ml_quantity) # typecasting to int
            if color == "red":
                red_ml += ml_quantity
            elif color == "green":
                green_ml += ml_quantity
            elif color == "blue":
                blue_ml += ml_quantity
            elif color == "dark":
                dark_ml += ml_quantity

        order['potion_type'] = [red_ml, green_ml, blue_ml, dark_ml]
        order['quantity'] = quantity
        bottle_plan.append(order)

    # Presumably, if we passed barrels, we should have enough ml to fulfill the strategy
    return json.loads(json.dumps(bottle_plan))


def type_to_sku(potion_type):
    sku = []
    if potion_type[0] > 0:
        sku.append(f"{potion_type[0]}red")
    if potion_type[1] > 0:
        sku.append(f"{potion_type[1]}green")
    if potion_type[2] > 0:
        sku.append(f"{potion_type[2]}blue")
    if potion_type[3] > 0:
        sku.append(f"{potion_type[3]}dark")
    return "".join(sku)

if __name__ == "__main__":
    print(get_bottle_plan())
