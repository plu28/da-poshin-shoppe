from fastapi import APIRouter, Depends
from enum import Enum
from pydantic import BaseModel
from src.api import auth
import sqlalchemy
import json
import re
from src.utils import database as db
from src.tables import global_inventory as gi
from src.tables import catalog_table as ct
from src.utils import log
from src import prices
from src.tables import strategy as strat

router = APIRouter(
    prefix="/bottler",
    tags=["bottler"],
    dependencies=[Depends(auth.get_api_key)],
)

class PotionInventory(BaseModel):
    potion_type: list[int]
    quantity: int

@router.post("/deliver/{order_id}")
def post_deliver_bottles(potions_delivered: list[PotionInventory], order_id: int):
    """ """
    log.post_log(f"/deliver/{order_id}")

    # add potions to catalog table. if the potion doesn't exist, insert a new row
    for potion in potions_delivered:
        sku = type_to_sku(potion.potion_type)
        catalog_row = ct.CatalogInventory().retrieve(sku)

        red_ml = potion.potion_type[0]
        green_ml = potion.potion_type[1]
        blue_ml = potion.potion_type[2]
        dark_ml = potion.potion_type[3]

        price = red_ml * prices.RED_PRICE_PER_ML + green_ml * prices.GREEN_PRICE_PER_ML + blue_ml * prices.BLUE_PRICE_PER_ML + dark_ml * prices.DARK_PRICE_PER_ML

        if (catalog_row == None):
            # TODO: Make it so the name is generated by an LLM to make it interesting
            insert_query = sqlalchemy.text("INSERT INTO catalog (sku, name, quantity, price, potion_type) VALUES (:sku, :name, :quantity, :price, :potion_type)")
            with db.engine.begin() as connection:
                connection.execute(insert_query,
                    {
                        'sku': sku,
                        'name': sku,
                        'quantity': potion.quantity,
                        'price': price,
                        'potion_type': potion.potion_type
                    }
                )
        else:
            # Update existing sku
            update_query = sqlalchemy.text("UPDATE catalog SET quantity = :quantity WHERE sku = :sku")
            with db.engine.begin() as connection:
                connection.execute(update_query,
                    {
                        'quantity': catalog_row.quantity + potion.quantity,
                        'sku': sku
                    }
                )

        # Decrement global inventory by how much we just bottled
        red_loss = green_loss = blue_loss = dark_loss = 0
        red_loss = red_ml * potion.quantity
        green_loss = green_ml * potion.quantity
        blue_loss = blue_ml * potion.quantity
        dark_loss = dark_ml * potion.quantity

        global_inventory = gi.GlobalInventory().retrieve()

        # Check that we aren't delivering more than what we can
        try:
            assert global_inventory.red_ml >= red_loss, "Delivering potions with more red_ml than available"
            assert global_inventory.green_ml >= green_loss, "Delivering potions with more green_ml than available"
            assert global_inventory.blue_ml >= blue_loss, "Delivering potions with more blue_ml than available"
            assert global_inventory.dark_ml >= dark_loss, "Delivering potions with more dark_ml than available"
        except AssertionError as e:
            print(f"AssertionError: {e}")
            return "ERROR"

        update_query = sqlalchemy.text("UPDATE global_inventory SET red_ml = :red_ml, green_ml = :green_ml, blue_ml = :blue_ml, dark_ml = :dark_ml")
        with db.engine.begin() as connection:
            connection.execute(update_query,
                {
                    'red_ml': global_inventory.red_ml - red_loss,
                    'green_ml': global_inventory.green_ml - green_loss,
                    'blue_ml': global_inventory.blue_ml - blue_loss,
                    'dark_ml': global_inventory.dark_ml - dark_loss
                }
            )

    return "OK"

@router.post("/plan")
def get_bottle_plan():
    """
    Go from barrel to bottle.
    """
    log.post_log('/bottler/plan')


    global_inventory = gi.GlobalInventory().retrieve()
    available_red = global_inventory.red_ml
    available_green = global_inventory.green_ml
    available_blue = global_inventory.blue_ml
    available_dark = global_inventory.dark_ml

    bottle_plan = []
    mystrat = strat.Strategy().retrieve_as_dict()
    for sku, quantity in mystrat.items():
        if quantity == 0:
            continue
        red_ml = green_ml = blue_ml = dark_ml = 0
        order = {}
        # Since sku corresponds to potion makeup, I can use regex
        for ml_quantity, color in re.findall(r"(\d+)([a-z]+)", sku):
            ml_quantity = int(ml_quantity) # typecasting to int
            if color == "red":
                available_red -= ml_quantity
                red_ml += ml_quantity
            elif color == "green":
                available_green -= ml_quantity
                green_ml += ml_quantity
            elif color == "blue":
                available_blue -= ml_quantity
                blue_ml += ml_quantity
            elif color == "dark":
                available_dark -= ml_quantity
                dark_ml += ml_quantity

        # Check that we aren't bottling more than what's available
        try:
            assert available_red >= 0, "Bottling more red_ml than available"
            assert available_green >= 0, "Bottling more green_ml than available"
            assert available_blue >= 0, "Bottling more blue_ml than available"
            assert available_dark >= 0, "Bottling more dark_ml than available"
        except AssertionError as e:
            print(f"AssertionError: {e}")
            return []

        order['potion_type'] = [red_ml, green_ml, blue_ml, dark_ml]
        order['quantity'] = quantity
        bottle_plan.append(order)

    return json.loads(json.dumps(bottle_plan))


def type_to_sku(potion_type):
    sku = []
    if potion_type[0] > 0:
        sku.append(f"{potion_type[0]}red")
    if potion_type[1] > 0:
        sku.append(f"{potion_type[1]}green")
    if potion_type[2] > 0:
        sku.append(f"{potion_type[2]}blue")
    if potion_type[3] > 0:
        sku.append(f"{potion_type[3]}dark")
    return "".join(sku)

if __name__ == "__main__":
    print(get_bottle_plan())
